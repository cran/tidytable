% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/arrange.R, R/bind.R, R/case.R, R/count.R,
%   R/deprec-dt_verb.R, R/distinct.R, R/drop_na.R, R/fill.R, R/filter.R,
%   R/get_dummies.R, R/group_split.R, R/ifelse.R, R/join.R, R/map.R, R/map2.R,
%   R/mutate.R, R/mutate_across.R, R/n.R, R/nest.R, R/pivot_longer.R,
%   R/pivot_wider.R, R/pull.R, R/relocate.R, R/rename.R, R/rename_with.R,
%   R/replace_na.R, R/row_number.R, R/select.R, R/separate.R, R/slice.R,
%   R/summarize.R, R/transmute.R, R/unite.R, R/unnest.R
\name{dt_arrange}
\alias{dt_arrange}
\alias{dt_bind_rows}
\alias{dt_bind_cols}
\alias{dt_case}
\alias{dt_count}
\alias{dt_verb}
\alias{dt_distinct}
\alias{dt_drop_na}
\alias{dt_fill}
\alias{dt_filter}
\alias{dt_get_dummies}
\alias{dt_group_split}
\alias{dt_ifelse}
\alias{dt_left_join}
\alias{dt_inner_join}
\alias{dt_right_join}
\alias{dt_full_join}
\alias{dt_anti_join}
\alias{dt_map}
\alias{dt_map_lgl}
\alias{dt_map_int}
\alias{dt_map_dbl}
\alias{dt_map_chr}
\alias{dt_map_dfc}
\alias{dt_map_dfr}
\alias{dt_map_df}
\alias{dt_map2}
\alias{dt_map2_lgl}
\alias{dt_map2_int}
\alias{dt_map2_dbl}
\alias{dt_map2_chr}
\alias{dt_map2_dfc}
\alias{dt_map2_dfr}
\alias{dt_map2_df}
\alias{dt_mutate}
\alias{dt_mutate_across}
\alias{dt_n}
\alias{dt_group_nest}
\alias{dt_pivot_longer}
\alias{dt_pivot_wider}
\alias{dt_pull}
\alias{dt_relocate}
\alias{dt_rename}
\alias{dt_rename_with}
\alias{dt_replace_na}
\alias{dt_row_number}
\alias{dt_select}
\alias{dt_separate}
\alias{dt_slice}
\alias{dt_slice_head}
\alias{dt_slice_tail}
\alias{dt_slice_min}
\alias{dt_slice_max}
\alias{dt_summarise}
\alias{dt_summarize}
\alias{dt_transmute}
\alias{dt_unite}
\alias{dt_unnest_legacy}
\title{Deprecated dt_verb() functions}
\usage{
dt_arrange(.df, ...)

dt_bind_rows(..., .id = NULL, .use_names = TRUE, .fill = TRUE)

dt_bind_cols(...)

dt_case(..., default = NA)

dt_count(.df, ...)

dt_distinct(.df, ..., .keep_all = FALSE)

dt_drop_na(.df, ...)

dt_fill(
  .df,
  ...,
  .direction = c("down", "up", "downup", "updown"),
  .by = NULL,
  by = NULL
)

dt_filter(.df, ..., .by = NULL, by = NULL)

dt_get_dummies(
  .df,
  cols = c(where(is.character), where(is.factor)),
  prefix = TRUE,
  prefix_sep = "_",
  drop_first = FALSE,
  dummify_na = TRUE
)

dt_group_split(.df, ..., .keep = TRUE)

dt_ifelse(conditions, true, false, na = NA)

dt_left_join(x, y, by = NULL)

dt_inner_join(x, y, by = NULL)

dt_right_join(x, y, by = NULL)

dt_full_join(x, y, by = NULL, suffix = c(".x", ".y"))

dt_anti_join(x, y, by = NULL)

dt_map(.x, .f, ...)

dt_map_lgl(.x, .f, ...)

dt_map_int(.x, .f, ...)

dt_map_dbl(.x, .f, ...)

dt_map_chr(.x, .f, ...)

dt_map_dfc(.x, .f, ...)

dt_map_dfr(.x, .f, ..., .id = NULL)

dt_map_df(.x, .f, ...)

dt_map2(.x, .y, .f, ...)

dt_map2_lgl(.x, .y, .f, ...)

dt_map2_int(.x, .y, .f, ...)

dt_map2_dbl(.x, .y, .f, ...)

dt_map2_chr(.x, .y, .f, ...)

dt_map2_dfc(.x, .y, .f, ...)

dt_map2_dfr(.x, .y, .f, ..., .id = NULL)

dt_map2_df(.x, .y, .f, ..., .id = NULL)

dt_mutate(.df, ..., .by = NULL, by = NULL)

dt_mutate_across(.df, .cols = everything(), .fns, ..., .by = NULL, by = NULL)

dt_n()

dt_group_nest(.df, ..., .key = "data", .keep = FALSE)

dt_pivot_longer(
  .df,
  cols = everything(),
  names_to = "name",
  values_to = "value",
  values_drop_na = FALSE,
  ...
)

dt_pivot_wider(
  .df,
  names_from = name,
  values_from = value,
  id_cols = NULL,
  names_sep = "_",
  values_fn = NULL
)

dt_pull(.df, var = NULL)

dt_relocate(.df, ..., .before = NULL, .after = NULL)

dt_rename(.df, ...)

dt_rename_with(.df, .fn, .cols = everything(), ...)

dt_replace_na(.x, replace = NA)

dt_row_number()

dt_select(.df, ...)

dt_separate(.df, col, into, sep = "[^[:alnum:]]+", remove = TRUE, ...)

dt_slice(.df, rows = 1:5, .by = NULL, by = NULL)

dt_slice_head(.df, n = 5, .by = NULL, by = NULL)

dt_slice_tail(.df, n = 5, .by = NULL, by = NULL)

dt_slice_min(.df, order_by, n = 1, .by = NULL, by = NULL)

dt_slice_max(.df, order_by, n = 1, .by = NULL, by = NULL)

dt_summarise(.df, ..., .by = NULL, by = NULL)

dt_summarize(.df, ..., .by = NULL, by = NULL)

dt_transmute(.df, ..., .by = NULL, by = NULL)

dt_unite(.df, col = "new_col", ..., sep = "_", remove = TRUE, na.rm = FALSE)

dt_unnest_legacy(.df, ..., .keep_all = FALSE)
}
\arguments{
\item{.df}{A data.frame or data.table}

\item{...}{Variables to arrange by}

\item{.id}{If TRUE, an integer column is made as a group id}

\item{.use_names}{If TRUE, makes sure column names align}

\item{.fill}{If TRUE, fills missing columns with NA}

\item{default}{Default value. Set to NA by default.}

\item{.keep_all}{Only relevant if columns are provided to ... arg.
This keeps all columns, but only keeps the first row of each distinct
values of columns provided to ... arg.}

\item{.direction}{Direction in which to fill missing values. Currently "down" (the default), "up", "downup" (first down then up), or "updown" (first up and then down)}

\item{.by}{Columns to group by when filling should be done by group}

\item{by}{This argument has been renamed to .by and is deprecated}

\item{cols}{A single column or a vector of unquoted columns to dummify.
Defaults to all character & factor columns using \code{c(is.character, is.factor)}.
\code{tidyselect} compatible.}

\item{prefix}{TRUE/FALSE - If TRUE, a prefix will be added to new column names}

\item{prefix_sep}{Separator for new column names}

\item{drop_first}{TRUE/FALSE - If TRUE, the first dummy column will be dropped}

\item{dummify_na}{TRUE/FALSE - If TRUE, NAs will also get dummy columns}

\item{.keep}{Should the grouping columns be kept}

\item{conditions}{Conditions to test on}

\item{true}{Values to return if conditions evaluate to TRUE}

\item{false}{Values to return if conditions evaluate to FALSE}

\item{na}{Value to return if an element of test is NA.}

\item{x}{A data.frame or data.table}

\item{y}{A data.frame or data.table}

\item{suffix}{Append created for duplicated column names when using \code{full_join.()}}

\item{.x}{A data.frame or data.table}

\item{.f}{A function}

\item{.y}{A data.frame or data.table}

\item{.cols}{A single column or a vector of unquoted columns to dummify.
Defaults to all character & factor columns using \code{c(is.character, is.factor)}.
\code{tidyselect} compatible.}

\item{.fns}{Functions to pass. Can pass a list of functions.}

\item{.key}{Name of the new column created by nesting.}

\item{names_to}{Name of the new "names" column. Must be a string.}

\item{values_to}{Name of the new "values" column. Must be a string.}

\item{values_drop_na}{If TRUE, rows will be dropped that contain NAs.}

\item{names_from}{A pair of arguments describing which column (or columns) to get the name of the output column (\code{name_from}),
and which column (or columns) to get the cell values from (\code{values_from}).
\code{tidyselect} compatible.}

\item{values_from}{A pair of arguments describing which column (or columns) to get the name of the output column (\code{name_from}),
and which column (or columns) to get the cell values from (\code{values_from}).
\code{tidyselect} compatible.}

\item{id_cols}{A set of columns that uniquely identifies each observation.
Defaults to all columns in the data table except for the columns specified in \code{names_from} and \code{values_from}.
Typically used when you have additional variables that is directly related.
\code{tidyselect} compatible.}

\item{names_sep}{the separator between the names of the columns}

\item{values_fn}{Should the data be aggregated before casting? If the formula doesn't identify a single observation for each cell, then aggregation defaults to length with a message.}

\item{var}{The column to pull from the data.table. If NULL, pulls the last column.}

\item{.before}{Column to move selection before}

\item{.after}{Column to move selection after}

\item{.fn}{Function to transform the names with.}

\item{replace}{If \code{.x} is a data frame, a \code{list()} of replacement values for specified columns.
If \code{.x} is a vector, a single replacement value.}

\item{col}{The column to split into multiple columns}

\item{into}{New column names to split into. A character vector.}

\item{sep}{Separator to split on. Can be specified or detected automatically}

\item{remove}{If TRUE, remove the input column from the output data.table}

\item{rows}{Integer row values. Provide either positive values to keep, or negative values to drop. The values provided must be either all positive or all negative.}

\item{n}{Number of rows to grab}

\item{order_by}{Variable to arrange by}

\item{na.rm}{If TRUE, NA values will be not be part of the concatenation}
}
\description{
\code{tidytable} was originally built using \code{dt_verb()} syntax.
These functions have since been deprecated.

Please use the \code{verb.()} versions in your code,
as the \code{dt_verb()} functions will be removed by the end of 2020.
}
